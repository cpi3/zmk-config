#!/usr/bin/env python3
"""
Simple helper to import ZMK Studio export files into this config repo.

Supported inputs:
 - ZMK DTS keymap files (contains `compatible = "zmk,keymap";`) -> copied into target keymap
 - JSON exports that include a `dts` or `keymap` string field (best-effort)

Usage:
  python scripts/import_studio_export.py <input-file> [--target <path>]

If --target is omitted, the script will try to place the file into
`config/boards/shields/cygnus/cygnus.keymap` if that shield exists, else
`config/cygnus.keymap`.

This is a minimal, safe tool — it will not attempt automated layout mapping.
Use it to quickly import Studio's exported DTS or keymap files into the repo.
"""
import argparse
import json
import os
import sys

DEFAULT_SHIELD_PATH = os.path.join("config", "boards", "shields", "cygnus", "cygnus.keymap")
DEFAULT_ROOT_PATH = os.path.join("config", "cygnus.keymap")


def choose_default_target():
    if os.path.exists(os.path.dirname(DEFAULT_SHIELD_PATH)):
        return DEFAULT_SHIELD_PATH
    return DEFAULT_ROOT_PATH


def main():
    p = argparse.ArgumentParser()
    p.add_argument("input", help="Path to Studio export file (.dtsi, .keymap, .json)")
    p.add_argument("--target", help="Destination keymap path in the repo")
    args = p.parse_args()

    inp = args.input
    if not os.path.exists(inp):
        print(f"Input file not found: {inp}")
        sys.exit(2)

    with open(inp, "r", encoding="utf-8") as f:
        data = f.read()

    target = args.target or choose_default_target()
    os.makedirs(os.path.dirname(target), exist_ok=True)

    # Heuristic: if the file already looks like a DTS keymap, copy it
    if 'compatible = "zmk,keymap"' in data or 'compatible = "zmk,keymap";' in data or inp.endswith(('.dtsi', '.keymap')):
        with open(target, "w", encoding="utf-8") as out:
            out.write(data)
        print(f"Imported keymap-like file to {target}")
        return

    # If JSON, attempt to find a 'dts' or 'keymap' field
    if inp.endswith('.json') or data.strip().startswith('{'):
        try:
            j = json.loads(data)
        except Exception:
            print("Input looks like JSON but failed to parse. Aborting.")
            sys.exit(3)
        # best-effort extraction
        if isinstance(j, dict):
            for key in ("dts", "dtsi", "keymap", "zmk_keymap", "zmk"):
                if key in j and isinstance(j[key], str) and ('compatible = "zmk,keymap"' in j[key] or 'keymap' in j[key]):
                    with open(target, "w", encoding="utf-8") as out:
                        out.write(j[key])
                    print(f"Extracted DTS from JSON field '{key}' to {target}")
                    return

            # If Studio provides structured layers, try to map into a simple DTS bindings block
            # Common Studio exports include a `layers` list where each layer is a flat list of key identifiers.
            if 'layers' in j and isinstance(j['layers'], list) and len(j['layers']) > 0:
                layer0 = j['layers'][0]
                # Expect layer to be a flat list of key strings
                if isinstance(layer0, list):
                    # Determine expected keycount from existing target if present
                    expected = None
                    if os.path.exists(target):
                        with open(target, 'r', encoding='utf-8') as cur:
                            curtext = cur.read()
                            expected = curtext.count('&kp')
                    # fallback to count from existing layer length
                    if expected is None:
                        expected = len(layer0)

                    if len(layer0) == expected:
                        # build a minimal DTS keymap file with one layer using the provided key names
                        bindings = []
                        for k in layer0:
                            token = str(k).strip()
                            # If token already looks like a ZMK binding, use as-is
                            if token.startswith('&') or token.startswith('kp') or token.startswith('mo') or ' ' in token:
                                bindings.append(token)
                            else:
                                # try to normalize common key names (Studio may use uppercase like 'A' or 'KC_A')
                                tok = token
                                if tok.startswith('KC_'):
                                    tok = tok[3:]
                                # map simple letter/digit to &kp NAME
                                bindings.append(f"&kp {tok}")

                        # write basic DTS structure
                        dts = []
                        dts.append('/* Generated by scripts/import_studio_export.py — review before commit */')
                        dts.append('#include <behaviors.dtsi>')
                        dts.append('#include <dt-bindings/zmk/keys.h>')
                        dts.append('\n/ {')
                        dts.append('    keymap {')
                        dts.append('        compatible = "zmk,keymap";')
                        dts.append('')
                        dts.append('        default_layer {')
                        dts.append('            bindings = <')
                        # join bindings in rows of reasonable width (12 per row as a heuristic)
                        per_row = 12
                        for i, b in enumerate(bindings):
                            if i % per_row == 0:
                                dts.append('')
                            dts[-1] = (dts[-1] + ' ' + b) if dts[-1] else b
                        dts.append('            >;')
                        dts.append('        };')
                        dts.append('    };')
                        dts.append('};')

                        with open(target, 'w', encoding='utf-8') as out:
                            out.write('\n'.join(dts))
                        print(f"Generated DTS keymap for {target} from Studio 'layers' field (best-effort). Please review.")
                        return
            # fallback: pretty-print JSON into a .json in scripts/imports for review
            fallback = os.path.join("scripts", "imports")
            os.makedirs(fallback, exist_ok=True)
            outp = os.path.join(fallback, os.path.basename(inp))
            with open(outp, "w", encoding="utf-8") as out:
                json.dump(j, out, indent=2)
            print(f"Could not extract DTS from JSON. Saved parsed JSON for inspection: {outp}")
            print("If the Studio export contains raw DTS, re-run with that DTS file or copy the DTS field into a .keymap file manually.")
            return

    print("Unrecognized export format. Please export a DTS keymap from ZMK Studio or provide a JSON containing a 'dts'/'keymap' field.")
    sys.exit(4)


if __name__ == '__main__':
    main()
